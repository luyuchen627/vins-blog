(window.webpackJsonp=window.webpackJsonp||[]).push([[92],{228:function(t,e,r){"use strict";r.r(e);var s=r(0),i=Object(s.a)({},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",{staticClass:"content"},[t._m(0),t._v(" "),r("p",[t._v("数据流有单向和双向之分，在mvvm或者mvc应用中，如果view的只和model有关，那么数据就是单向的，如果除了和model,还和controller，或者用户交互，dom事件有关，那么数据就是双向的")]),t._v(" "),r("p",[t._v("例如，在vue中，v-bind就是单向绑定，形成单向数据流，而v-model是双向绑定，形成双向数据流；v-model的本质是v-bind和eventlistener的封装")]),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),r("p",[t._v("那么封装能带来什么不一样的变化？")]),t._v(" "),t._m(3),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),t._m(6),t._v(" "),r("p",[t._v("替代双向绑定中的直接修改变为触发action，间接修改")]),t._v(" "),t._m(7),t._v(" "),t._m(8),t._v(" "),r("ul",[r("li",[r("p",[r("a",{attrs:{href:"https://www.zhihu.com/question/49964363/answer/136022879",target:"_blank",rel:"noopener noreferrer"}},[t._v("单向数据绑定和双向数据绑定的优缺点"),r("OutboundLink")],1)])]),t._v(" "),r("li",[r("p",[r("a",{attrs:{href:"https://www.cnblogs.com/answershuto/p/7752970.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("vuex源码解析"),r("OutboundLink")],1)])])])])},[function(){var t=this.$createElement,e=this._self._c||t;return e("h1",{attrs:{id:"数据流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据流","aria-hidden":"true"}},[this._v("#")]),this._v(" 数据流")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"状态管理的数据流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#状态管理的数据流","aria-hidden":"true"}},[this._v("#")]),this._v(" 状态管理的数据流")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("在 "),e("strong",[this._v("flux")]),this._v(", "),e("strong",[this._v("redux")]),this._v(", "),e("strong",[this._v("vuex")]),this._v(" 等状态管理框架中，都是提倡单向数据流，及 action -> dispatch -> store -> view -> dispatch；如果把view以外的看为一个整体store,那么就变为：store <-> view，即双向数据流；可见单向双向这是框架封装的效果，本质是一样的")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("最重要的变化就是："),e("strong",[this._v("view")]),this._v(" 的变化，只能来自 "),e("strong",[this._v("store")]),this._v("，有一个统一的来源，我们就能更好的进行状态监听和跟踪，记录，减少别的改动带来错误变化；缺点就是数据流变长，代码增加，在表单形绑定的时候会比较繁琐")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"对state的直接修改问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对state的直接修改问题","aria-hidden":"true"}},[this._v("#")]),this._v(" 对state的直接修改问题")])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("p",[t._v("在 "),r("strong",[t._v("redux")]),t._v(" 中，store中存储的是普通的对象，我们直接修改，不会报错，但是不会触发store的变化监听事件，不能同步渲染；而在 "),r("strong",[t._v("vuex")]),t._v(" 中的严格模式中, 通过"),r("strong",[t._v("store._vm.$weatch")]),t._v(" 监听state变化，判断内部 "),r("strong",[t._v("_committing")]),t._v(" 状态，来确实是不是 "),r("strong",[t._v("mutation")]),t._v(" 触发的，"),r("strong",[t._v("vuex")]),t._v(" 的内部的所有 "),r("strong",[t._v("mutation")]),t._v(" 的触发，都会经过 "),r("strong",[t._v("_withCommit")]),t._v(" 方法，该方法同步修改 "),r("strong",[t._v("_committing")]),t._v(", 因此异步的修改不会被监听到")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"v-model双向绑定到单向数据流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#v-model双向绑定到单向数据流","aria-hidden":"true"}},[this._v("#")]),this._v(" v-model双向绑定到单向数据流")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("使用事件触发action")]),this._v(" "),e("li",[this._v("使用set函数触发")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"参考"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考","aria-hidden":"true"}},[this._v("#")]),this._v(" 参考")])}],!1,null,null,null);e.default=i.exports}}]);